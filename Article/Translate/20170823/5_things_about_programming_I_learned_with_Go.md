[译]我从Go中学到的五点
《5 things about programming I learned with Go》(http://mjk.space/5-things-about-programming-learned-with-go/)

在最近几个月，Go越发变得出名起来。与其相关的文章和博客几乎每天都有更新，Github上也新建了大量的Go工程。越来越多的人参与Go的研讨会和聚会中。Go现在势头正猛，甚至在2016年获得了TIOBE的年度最佳语言，而最近甚至排在了Top 10的行列之中。

我是一年前开始接触并学习Go的。在尝试了一段时间后，我坚定的认为Go是一门值得你去学习的语言。即便你不打算长期使用Go，短暂的学习了解也可以有助于你提高你的编程技巧。在这篇文章中我总结了从Go中学习到的五个方面，而这几个方面在其他语言中很难看到。

## 1. 可以在拥有动态语言语法的同时保证静态语言的安全性
在日常工作中我主要使用Ruby，并且非常享受它带来的动态类型系统。而这个特点使得它易学、易用并且生产效率较高。然而根据我的经验，对于小型项目，Ruby工作的非常好。但是随着项目的扩增变得越来越复杂，我越来越感觉到缺失了静态语言提供的安全性和可靠性。即使我仔细的进行了测试，它还是可能会在一些我们没有覆盖的边际条件那发生一些我不希望发生的事。有可能有一门既拥有动态语言的语法特定同时也具备了静态语言的安全的语言么？让我们来看看Go的表现。

** Go不是一门面向对象的语音  ** 一直有对Go是不是一门面向对象的语言的争论，有时候甚至争论者自己都没法自圆其说。但是Go的确是拥有了面向对象语言的接口的特性。而且和Java、C++中的接口表现类似。接口包含了名字和定义的接口方法签名：

    type Animal interface {
        Speak() string
    }

Go拥有和"Class"类似的结构"Struct"，"Struct"将一堆属性组合到了一起：

    type Dog struct {
        name string
    }

然后我们可以定义"Struct"的方法：

    func (d Dog) Speak() string {
        return "Woof!"
    }


这样，就可以调用`Dog`示例的方法了。

第一次看到上面的代码可能会觉得有点奇怪。为什么要在"Struct"定义的外面写函数。这里函数签名的`(d Dog)`又是什么意思？让我一一道来。

Go的作者在设计Go的时候，希望用户可以灵活的为"Struct"增加新的逻辑方法，甚至非库文件的作者都可以为"Struct"增加新的方法，所以这里将函数实现写到"Struct"定义的外面。而编译器需要知道这个方法是归属于哪个"Struct"的，所以需要在方法的前面加上方法的接受对象。

这里我写一个简单示例函数来使用上面的数据结构，他使用了一个`Animal`作为参数：

    func SaySomething(a Animal) {
        fmt.Println(a.Speak())
    }

如你所想，这里我们会将一个`Dog`对象传递给`SaySomething`方法

    dog := Dog{name: "Charlie"}
    SaySomething(dog)

"非常好",你可能这样觉得，"但是为了实现`Animal`接口`Dog` 结构体做了什么呢？"

不用做任何事，他就已经实现了接口了。Go使用了一种称为"automatic interface implementation（自动实现接口）"的概念.实现结构对象包含了接口定义中所有的方法。没有`implements`关键字，非常酷是不是?

我的一个朋友称之为"a statically typed duck typing（鸭式类型）",来自于寓言：

> “If it quacks like a duck, then it probably is a duck”.
>
> [译]：
>     如果它叫起来像鸭子，那么他就是鸭子

得益于这个特性以及在定义变量时可以通过类型推导省略变量类型的书写。让我们觉得这就像使用动态语言一样方便，但同时他也是静态安全的。

这点为何如此重要？如果你的工程是用一门动态的高抽象的语言来实现，某天你发现有个模块需要使用一个低级的编译型语言来实现。我注意到对于Ruby和Python程序猿来说，抛弃他们熟悉的灵活性来使用静态语言是非常难的，但是用一个"statically-duck-typed"的Go却相对容易。

2. 组合比继承更好

在我的前面一篇文章（http://mjk.space/how-to-avoid-inheritance-in-ruby/）我描述了一个过渡使用面向对象特性遇到的问题。

我讲述了一个用单个类来模拟客户对软件的需求。然后客户扩展了他的需求，此时通过继承之前的仿佛完美的解决了问题，但是不行的是，随着客户不断提需求，类的集成关系变的越来越复杂巨大，使得代码维护和复用变的特别困难。


